package com.dataStructure;

/**
 * @Author: leaderHoo
 * @Date: 2019/12/20 15:16
 * @desc:
 */
public class TreeDefine {
    //当数据具有有序性，基于线性表的二叉查找算法复杂度O(logN) ,当数据没有有序性时

}

//树的定义 ： 是n（n>=0）个节点组成的集合，n=0时是空树 ，
// 这个集合的特点： 1.有一个称为"树根"的节点； 2.其他节点分为m个"不相交"的子集, 每个子集又是一棵树
// 树的定义采用 ：递归的形式
// 树可以表示为一个二元组  Tree =(root,forest),root是根节点，forest是各个子树构
// 树的概念 ：
//1. 节点的度 ： 节点的子树个数
//2. 节点的层：根节点是一层，其他节点层是其父节点层+1
//3. 树的深度： 节点的最大层数就是树的深度， 举例，只有根节点，深度为1，右儿子 深度+1
//4. 树的高度： 和深度类似，不同在于自底向上，儿子是1，父亲是儿子的高度最大值+1
abstract  class Tree<T>{
    T root;
    Tree son1,son2,son3; //....可能会更多
}


// 二叉树 ： 父亲最多拥有左右两棵子树，这里具体一下，
// Node表示节点，BinaryTree从根节点入手（root），通过root可达任意节点
class BinaryTree<T>{
    private class Node<T>{
        Node<T> left,right;
        T value;
    }
    Node<T> root; //根节点
}
// 二叉树概念
//1. N个节点二叉树，最坏深度是O(N)-斜二叉树,最佳深度是O(logN)-满二叉树或完美二叉树 平均深度是O（sqrt(N)）
//2. 完全二叉树，叶子节点只可能出现在最下层和次下层

//二叉树性质
//1. 第i层的节点数，最多是2^{i-1}
//2. 深度为k的二叉树，最多有2^k -1个节点 ，同理n个节点的二叉树深度是logN+1
//3. 设N0表示度为0的节点个数，N2表示度为2的节点个数， N0= N2 + 1 (叶子节点个数之和 = 有两个儿子节点个数之和+1)
//证明 总结点数设为N,边数设为B ,则 B = N -1 ,
// 同时B=N1+2*N2 , 得出N = N1+2*N2+1, 同时节点数N=N0+N1+N2,


